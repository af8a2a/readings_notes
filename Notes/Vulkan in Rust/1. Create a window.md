
æœ¬ç« å°†åŸºäº`winit`åˆ›å»ºwindowçª—å£ã€‚


é¦–å…ˆï¼Œæˆ‘ä»¬ä»winitçš„[æ–‡æ¡£ç¤ºä¾‹](https://docs.rs/winit/latest/winit/)å¼€å§‹

winitéœ€è¦åˆ›å»ºä¸€ä¸ª`Eventloop`ï¼Œæ„å»ºæ¡Œé¢åº”ç”¨ç¨‹åºçš„äº‹ä»¶å¾ªç¯ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºè¿è¡Œçš„å…³é”®ã€‚
ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬åœ¨ä¸»ç¨‹åºå®šä¹‰äº†ä¸€ä¸ª`EventLoop`ï¼Œè®¾ç½®äº†æ§åˆ¶æµ
```rust
fn main() {

Â  Â  let event_loop = EventLoop::new().unwrap();


Â  Â  // ControlFlow::Poll continuously runs the event loop, even if the OS hasn't

Â  Â  // dispatched any events. This is ideal for games and similar applications.

Â  Â  event_loop.set_control_flow(ControlFlow::Poll);

Â  Â  let mut app = App::default();

  

Â  Â  event_loop.run_app(&mut app).unwrap();

}
```

> å¦‚æœä½ æ›¾ç»æœ‰ç¼–å†™è¿‡Linuxä¸‹çš„ç½‘ç»œç¨‹åºç»éªŒï¼Œä¸€å®šå¯¹è¿™æ ·çš„ä»£ç å¹¶ä¸é™Œç”Ÿ.....  



å—¯ï¼Œä»£ç å¹¶ä¸èƒ½è¿è¡Œï¼Œå› ä¸ºæˆ‘ä»¬å¹¶æ²¡æœ‰å®šä¹‰Appç±»å‹ï¼Œå…ˆå®šä¹‰ä¸€ä¸ªç®€å•çš„Appç»“æ„ä½“ï¼Œè§£å†³è¿™ä¸ªæŠ¥é”™ã€‚
```rust
use std::num::NonZeroU32;
use winit::application::ApplicationHandler;
use winit::dpi::PhysicalSize;
use winit::event::WindowEvent;
use winit::event_loop::{ActiveEventLoop, ControlFlow, EventLoop};
use winit::window::{Window, WindowId};
#[derive(Default)]
struct App {
    window: Option<Window>,
}

impl ApplicationHandler for App {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        self.window = Some(
            event_loop
                .create_window(Window::default_attributes())
                .unwrap(),
        );
    }

    fn window_event(&mut self, event_loop: &ActiveEventLoop, id: WindowId, event: WindowEvent) {

        match event {
            WindowEvent::CloseRequested => {
                println!("The close button was pressed; stopping");
                event_loop.exit();
            }
            
            WindowEvent::RedrawRequested => {
                self.window.as_ref().unwrap().request_redraw();
            }
            _ => (),
        }
    }
}

fn main() {

Â  Â  let event_loop = EventLoop::new().unwrap();


Â  Â  // ControlFlow::Poll continuously runs the event loop, even if the OS hasn't

Â  Â  // dispatched any events. This is ideal for games and similar applications.

Â  Â  event_loop.set_control_flow(ControlFlow::Poll);

Â  Â  let mut app = App::default();

  

Â  Â  event_loop.run_app(&mut app).unwrap();

}
```

å¦‚æœä¸å‡ºæ„å¤–,ä½ åº”è¯¥èƒ½å¤Ÿè¿è¡Œè¿™ä¸ªç¨‹åºäº†ã€‚
![alt text](image_1/image_1_1.png)  
å—¯,ä»€ä¹ˆä¹Ÿæ²¡æœ‰,å’Œæˆ‘ä»¬çš„ä»£ç ä¸€æ ·....  
å¹¶ä¸”ï¼Œå¦‚æœä½ å°è¯•å¯¹è¿™ä¸ªçª—å£å°ºå¯¸è¿›è¡Œä¿®æ”¹,ä¼šå‡ºç°æ›´æç¬‘çš„ä¸€å¹•ğŸ˜…
![alt text](image_1/image_1_2.png)  

åŸå› æ˜¯,æˆ‘ä»¬çš„ç¨‹åºå¹¶æ²¡æœ‰å¯¹`WindowEvent::Resized`è¿™ä¸ªäº‹ä»¶è¿›è¡ŒåŒ¹é…,å¯¹ä¿®æ”¹å®Œå…¨å¼€æ‘†....  
ä¸è¿‡,è¿™ä¸æ˜¯æˆ‘ä»¬ç›®å‰çš„é‡ç‚¹,å…ˆå‡‘åˆç”¨ç”¨